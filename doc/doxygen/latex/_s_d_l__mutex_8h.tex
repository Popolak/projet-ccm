\hypertarget{_s_d_l__mutex_8h}{}\doxysection{Référence du fichier SDL/include/\+SDL\+\_\+mutex.h}
\label{_s_d_l__mutex_8h}\index{SDL/include/SDL\_mutex.h@{SDL/include/SDL\_mutex.h}}
{\ttfamily \#include \char`\"{}SDL\+\_\+stdinc.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}SDL\+\_\+error.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}begin\+\_\+code.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}close\+\_\+code.\+h\char`\"{}}\newline
\doxysubsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \mbox{\hyperlink{_s_d_l__mutex_8h_a1214610634c24465d7c50149752791a9}{SDL\+\_\+\+MUTEX\+\_\+\+TIMEDOUT}}~1
\item 
\#define \mbox{\hyperlink{_s_d_l__mutex_8h_abd2bc8605242c50341362ada961dc914}{SDL\+\_\+\+MUTEX\+\_\+\+MAXWAIT}}~($\sim$(Uint32)0)
\end{DoxyCompactItemize}
\doxysubsection*{Mutex functions}
\begin{DoxyCompactItemize}
\item 
\#define \mbox{\hyperlink{_s_d_l__mutex_8h_a3ce486805b5c21574466d3d93c908597}{SDL\+\_\+mutexP}}(m)~SDL\+\_\+\+Lock\+Mutex(m)
\item 
\#define \mbox{\hyperlink{_s_d_l__mutex_8h_aa25335079da2e776536c63e84288d684}{SDL\+\_\+mutexV}}(m)~SDL\+\_\+\+Unlock\+Mutex(m)
\item 
\mbox{\Hypertarget{_s_d_l__mutex_8h_ac085162a7cfb9ebd63e2d05d33c03c17}\label{_s_d_l__mutex_8h_ac085162a7cfb9ebd63e2d05d33c03c17}} 
typedef struct SDL\+\_\+mutex {\bfseries SDL\+\_\+mutex}
\item 
DECLSPEC SDL\+\_\+mutex $\ast$SDLCALL \mbox{\hyperlink{_s_d_l__mutex_8h_ae1f90ad6a7420fb3c4b5685e440d762f}{SDL\+\_\+\+Create\+Mutex}} (void)
\item 
\mbox{\Hypertarget{_s_d_l__mutex_8h_a0908c6a7356331d197059fbdc6c66a0f}\label{_s_d_l__mutex_8h_a0908c6a7356331d197059fbdc6c66a0f}} 
DECLSPEC int SDLCALL {\bfseries SDL\+\_\+\+Lock\+Mutex} (SDL\+\_\+mutex $\ast$mutex)
\item 
DECLSPEC int SDLCALL \mbox{\hyperlink{_s_d_l__mutex_8h_a5097fb4c7147d14a4c6df4515ec862e8}{SDL\+\_\+\+Try\+Lock\+Mutex}} (SDL\+\_\+mutex $\ast$mutex)
\item 
\mbox{\Hypertarget{_s_d_l__mutex_8h_afee1549c7723ebe13fbfca8ad94f8c9d}\label{_s_d_l__mutex_8h_afee1549c7723ebe13fbfca8ad94f8c9d}} 
DECLSPEC int SDLCALL {\bfseries SDL\+\_\+\+Unlock\+Mutex} (SDL\+\_\+mutex $\ast$mutex)
\item 
DECLSPEC void SDLCALL \mbox{\hyperlink{_s_d_l__mutex_8h_ad2bbcc4e32ac927af62f0cba671f63fe}{SDL\+\_\+\+Destroy\+Mutex}} (SDL\+\_\+mutex $\ast$mutex)
\end{DoxyCompactItemize}
\doxysubsection*{Semaphore functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{_s_d_l__mutex_8h_aa7d56df841e98eed229d1d4b17327d29}\label{_s_d_l__mutex_8h_aa7d56df841e98eed229d1d4b17327d29}} 
typedef struct SDL\+\_\+semaphore {\bfseries SDL\+\_\+sem}
\item 
DECLSPEC SDL\+\_\+sem $\ast$SDLCALL \mbox{\hyperlink{_s_d_l__mutex_8h_ab8c1a20a5466281a5d63a0cabe07e140}{SDL\+\_\+\+Create\+Semaphore}} (Uint32 initial\+\_\+value)
\item 
DECLSPEC void SDLCALL \mbox{\hyperlink{_s_d_l__mutex_8h_a23deb3b7e29a5137d804e4be3453a768}{SDL\+\_\+\+Destroy\+Semaphore}} (SDL\+\_\+sem $\ast$sem)
\item 
DECLSPEC int SDLCALL \mbox{\hyperlink{_s_d_l__mutex_8h_af51d75d18cb90f28b35c31e853b04792}{SDL\+\_\+\+Sem\+Wait}} (SDL\+\_\+sem $\ast$sem)
\item 
DECLSPEC int SDLCALL \mbox{\hyperlink{_s_d_l__mutex_8h_a517288aaa856ce2264e8420636e85c4a}{SDL\+\_\+\+Sem\+Try\+Wait}} (SDL\+\_\+sem $\ast$sem)
\item 
DECLSPEC int SDLCALL \mbox{\hyperlink{_s_d_l__mutex_8h_a4ea1acfaf722895626174e1e37c497da}{SDL\+\_\+\+Sem\+Wait\+Timeout}} (SDL\+\_\+sem $\ast$sem, Uint32 ms)
\item 
DECLSPEC int SDLCALL \mbox{\hyperlink{_s_d_l__mutex_8h_a0c50f774babf7a44c381238a1f780595}{SDL\+\_\+\+Sem\+Post}} (SDL\+\_\+sem $\ast$sem)
\item 
DECLSPEC Uint32 SDLCALL \mbox{\hyperlink{_s_d_l__mutex_8h_ae66390dca585fdab8de871fe32935768}{SDL\+\_\+\+Sem\+Value}} (SDL\+\_\+sem $\ast$sem)
\end{DoxyCompactItemize}
\doxysubsection*{Condition variable functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{_s_d_l__mutex_8h_ac50401d1b84d806a0c927c8cf454f96a}\label{_s_d_l__mutex_8h_ac50401d1b84d806a0c927c8cf454f96a}} 
typedef struct SDL\+\_\+cond {\bfseries SDL\+\_\+cond}
\item 
DECLSPEC SDL\+\_\+cond $\ast$SDLCALL \mbox{\hyperlink{_s_d_l__mutex_8h_ac729fb4dbfe4057452ebfc1087f61585}{SDL\+\_\+\+Create\+Cond}} (void)
\item 
DECLSPEC void SDLCALL \mbox{\hyperlink{_s_d_l__mutex_8h_a8843feeb270845e07fc23f692707540f}{SDL\+\_\+\+Destroy\+Cond}} (SDL\+\_\+cond $\ast$cond)
\item 
DECLSPEC int SDLCALL \mbox{\hyperlink{_s_d_l__mutex_8h_a1037a8274b0b13118fc78eeb417a1397}{SDL\+\_\+\+Cond\+Signal}} (SDL\+\_\+cond $\ast$cond)
\item 
DECLSPEC int SDLCALL \mbox{\hyperlink{_s_d_l__mutex_8h_a2ffd0b45ebdc44057007a59857ba46b3}{SDL\+\_\+\+Cond\+Broadcast}} (SDL\+\_\+cond $\ast$cond)
\item 
DECLSPEC int SDLCALL \mbox{\hyperlink{_s_d_l__mutex_8h_af759b2fe1c5507f47854c1edf1ecbabd}{SDL\+\_\+\+Cond\+Wait}} (SDL\+\_\+cond $\ast$cond, SDL\+\_\+mutex $\ast$mutex)
\item 
DECLSPEC int SDLCALL \mbox{\hyperlink{_s_d_l__mutex_8h_aa57013f95a9c608cf24a5100b841e863}{SDL\+\_\+\+Cond\+Wait\+Timeout}} (SDL\+\_\+cond $\ast$cond, SDL\+\_\+mutex $\ast$mutex, Uint32 ms)
\end{DoxyCompactItemize}


\doxysubsection{Description détaillée}
Functions to provide thread synchronization primitives. 

\doxysubsection{Documentation des macros}
\mbox{\Hypertarget{_s_d_l__mutex_8h_abd2bc8605242c50341362ada961dc914}\label{_s_d_l__mutex_8h_abd2bc8605242c50341362ada961dc914}} 
\index{SDL\_mutex.h@{SDL\_mutex.h}!SDL\_MUTEX\_MAXWAIT@{SDL\_MUTEX\_MAXWAIT}}
\index{SDL\_MUTEX\_MAXWAIT@{SDL\_MUTEX\_MAXWAIT}!SDL\_mutex.h@{SDL\_mutex.h}}
\doxysubsubsection{\texorpdfstring{SDL\_MUTEX\_MAXWAIT}{SDL\_MUTEX\_MAXWAIT}}
{\footnotesize\ttfamily \#define SDL\+\_\+\+MUTEX\+\_\+\+MAXWAIT~($\sim$(Uint32)0)}

This is the timeout value which corresponds to never time out. \mbox{\Hypertarget{_s_d_l__mutex_8h_a1214610634c24465d7c50149752791a9}\label{_s_d_l__mutex_8h_a1214610634c24465d7c50149752791a9}} 
\index{SDL\_mutex.h@{SDL\_mutex.h}!SDL\_MUTEX\_TIMEDOUT@{SDL\_MUTEX\_TIMEDOUT}}
\index{SDL\_MUTEX\_TIMEDOUT@{SDL\_MUTEX\_TIMEDOUT}!SDL\_mutex.h@{SDL\_mutex.h}}
\doxysubsubsection{\texorpdfstring{SDL\_MUTEX\_TIMEDOUT}{SDL\_MUTEX\_TIMEDOUT}}
{\footnotesize\ttfamily \#define SDL\+\_\+\+MUTEX\+\_\+\+TIMEDOUT~1}

Synchronization functions which can time out return this value if they time out. \mbox{\Hypertarget{_s_d_l__mutex_8h_a3ce486805b5c21574466d3d93c908597}\label{_s_d_l__mutex_8h_a3ce486805b5c21574466d3d93c908597}} 
\index{SDL\_mutex.h@{SDL\_mutex.h}!SDL\_mutexP@{SDL\_mutexP}}
\index{SDL\_mutexP@{SDL\_mutexP}!SDL\_mutex.h@{SDL\_mutex.h}}
\doxysubsubsection{\texorpdfstring{SDL\_mutexP}{SDL\_mutexP}}
{\footnotesize\ttfamily \#define SDL\+\_\+mutexP(\begin{DoxyParamCaption}\item[{}]{m }\end{DoxyParamCaption})~SDL\+\_\+\+Lock\+Mutex(m)}

Lock the mutex.

\begin{DoxyReturn}{Renvoie}
0, or -\/1 on error. 
\end{DoxyReturn}
\mbox{\Hypertarget{_s_d_l__mutex_8h_aa25335079da2e776536c63e84288d684}\label{_s_d_l__mutex_8h_aa25335079da2e776536c63e84288d684}} 
\index{SDL\_mutex.h@{SDL\_mutex.h}!SDL\_mutexV@{SDL\_mutexV}}
\index{SDL\_mutexV@{SDL\_mutexV}!SDL\_mutex.h@{SDL\_mutex.h}}
\doxysubsubsection{\texorpdfstring{SDL\_mutexV}{SDL\_mutexV}}
{\footnotesize\ttfamily \#define SDL\+\_\+mutexV(\begin{DoxyParamCaption}\item[{}]{m }\end{DoxyParamCaption})~SDL\+\_\+\+Unlock\+Mutex(m)}

Unlock the mutex.

\begin{DoxyReturn}{Renvoie}
0, or -\/1 on error.
\end{DoxyReturn}
\begin{DoxyWarning}{Avertissement}
It is an error to unlock a mutex that has not been locked by the current thread, and doing so results in undefined behavior. 
\end{DoxyWarning}


\doxysubsection{Documentation des fonctions}
\mbox{\Hypertarget{_s_d_l__mutex_8h_a2ffd0b45ebdc44057007a59857ba46b3}\label{_s_d_l__mutex_8h_a2ffd0b45ebdc44057007a59857ba46b3}} 
\index{SDL\_mutex.h@{SDL\_mutex.h}!SDL\_CondBroadcast@{SDL\_CondBroadcast}}
\index{SDL\_CondBroadcast@{SDL\_CondBroadcast}!SDL\_mutex.h@{SDL\_mutex.h}}
\doxysubsubsection{\texorpdfstring{SDL\_CondBroadcast()}{SDL\_CondBroadcast()}}
{\footnotesize\ttfamily DECLSPEC int SDLCALL SDL\+\_\+\+Cond\+Broadcast (\begin{DoxyParamCaption}\item[{SDL\+\_\+cond $\ast$}]{cond }\end{DoxyParamCaption})}

Restart all threads that are waiting on the condition variable.

\begin{DoxyReturn}{Renvoie}
0 or -\/1 on error. 
\end{DoxyReturn}
\mbox{\Hypertarget{_s_d_l__mutex_8h_a1037a8274b0b13118fc78eeb417a1397}\label{_s_d_l__mutex_8h_a1037a8274b0b13118fc78eeb417a1397}} 
\index{SDL\_mutex.h@{SDL\_mutex.h}!SDL\_CondSignal@{SDL\_CondSignal}}
\index{SDL\_CondSignal@{SDL\_CondSignal}!SDL\_mutex.h@{SDL\_mutex.h}}
\doxysubsubsection{\texorpdfstring{SDL\_CondSignal()}{SDL\_CondSignal()}}
{\footnotesize\ttfamily DECLSPEC int SDLCALL SDL\+\_\+\+Cond\+Signal (\begin{DoxyParamCaption}\item[{SDL\+\_\+cond $\ast$}]{cond }\end{DoxyParamCaption})}

Restart one of the threads that are waiting on the condition variable.

\begin{DoxyReturn}{Renvoie}
0 or -\/1 on error. 
\end{DoxyReturn}
\mbox{\Hypertarget{_s_d_l__mutex_8h_af759b2fe1c5507f47854c1edf1ecbabd}\label{_s_d_l__mutex_8h_af759b2fe1c5507f47854c1edf1ecbabd}} 
\index{SDL\_mutex.h@{SDL\_mutex.h}!SDL\_CondWait@{SDL\_CondWait}}
\index{SDL\_CondWait@{SDL\_CondWait}!SDL\_mutex.h@{SDL\_mutex.h}}
\doxysubsubsection{\texorpdfstring{SDL\_CondWait()}{SDL\_CondWait()}}
{\footnotesize\ttfamily DECLSPEC int SDLCALL SDL\+\_\+\+Cond\+Wait (\begin{DoxyParamCaption}\item[{SDL\+\_\+cond $\ast$}]{cond,  }\item[{SDL\+\_\+mutex $\ast$}]{mutex }\end{DoxyParamCaption})}

Wait on the condition variable, unlocking the provided mutex.

\begin{DoxyWarning}{Avertissement}
The mutex must be locked before entering this function!
\end{DoxyWarning}
The mutex is re-\/locked once the condition variable is signaled.

\begin{DoxyReturn}{Renvoie}
0 when it is signaled, or -\/1 on error. 
\end{DoxyReturn}
\mbox{\Hypertarget{_s_d_l__mutex_8h_aa57013f95a9c608cf24a5100b841e863}\label{_s_d_l__mutex_8h_aa57013f95a9c608cf24a5100b841e863}} 
\index{SDL\_mutex.h@{SDL\_mutex.h}!SDL\_CondWaitTimeout@{SDL\_CondWaitTimeout}}
\index{SDL\_CondWaitTimeout@{SDL\_CondWaitTimeout}!SDL\_mutex.h@{SDL\_mutex.h}}
\doxysubsubsection{\texorpdfstring{SDL\_CondWaitTimeout()}{SDL\_CondWaitTimeout()}}
{\footnotesize\ttfamily DECLSPEC int SDLCALL SDL\+\_\+\+Cond\+Wait\+Timeout (\begin{DoxyParamCaption}\item[{SDL\+\_\+cond $\ast$}]{cond,  }\item[{SDL\+\_\+mutex $\ast$}]{mutex,  }\item[{Uint32}]{ms }\end{DoxyParamCaption})}

Waits for at most {\ttfamily ms} milliseconds, and returns 0 if the condition variable is signaled, \mbox{\hyperlink{_s_d_l__mutex_8h_a1214610634c24465d7c50149752791a9}{SDL\+\_\+\+MUTEX\+\_\+\+TIMEDOUT}} if the condition is not signaled in the allotted time, and -\/1 on error.

\begin{DoxyWarning}{Avertissement}
On some platforms this function is implemented by looping with a delay of 1 ms, and so should be avoided if possible. 
\end{DoxyWarning}
\mbox{\Hypertarget{_s_d_l__mutex_8h_ac729fb4dbfe4057452ebfc1087f61585}\label{_s_d_l__mutex_8h_ac729fb4dbfe4057452ebfc1087f61585}} 
\index{SDL\_mutex.h@{SDL\_mutex.h}!SDL\_CreateCond@{SDL\_CreateCond}}
\index{SDL\_CreateCond@{SDL\_CreateCond}!SDL\_mutex.h@{SDL\_mutex.h}}
\doxysubsubsection{\texorpdfstring{SDL\_CreateCond()}{SDL\_CreateCond()}}
{\footnotesize\ttfamily DECLSPEC SDL\+\_\+cond$\ast$ SDLCALL SDL\+\_\+\+Create\+Cond (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}

Create a condition variable.

Typical use of condition variables\+:

Thread A\+: SDL\+\_\+\+Lock\+Mutex(lock); while ( ! condition ) \{ SDL\+\_\+\+Cond\+Wait(cond, lock); \} SDL\+\_\+\+Unlock\+Mutex(lock);

Thread B\+: SDL\+\_\+\+Lock\+Mutex(lock); ... condition = true; ... SDL\+\_\+\+Cond\+Signal(cond); SDL\+\_\+\+Unlock\+Mutex(lock);

There is some discussion whether to signal the condition variable with the mutex locked or not. There is some potential performance benefit to unlocking first on some platforms, but there are some potential race conditions depending on how your code is structured.

In general it\textquotesingle{}s safer to signal the condition variable while the mutex is locked. \mbox{\Hypertarget{_s_d_l__mutex_8h_ae1f90ad6a7420fb3c4b5685e440d762f}\label{_s_d_l__mutex_8h_ae1f90ad6a7420fb3c4b5685e440d762f}} 
\index{SDL\_mutex.h@{SDL\_mutex.h}!SDL\_CreateMutex@{SDL\_CreateMutex}}
\index{SDL\_CreateMutex@{SDL\_CreateMutex}!SDL\_mutex.h@{SDL\_mutex.h}}
\doxysubsubsection{\texorpdfstring{SDL\_CreateMutex()}{SDL\_CreateMutex()}}
{\footnotesize\ttfamily DECLSPEC SDL\+\_\+mutex$\ast$ SDLCALL SDL\+\_\+\+Create\+Mutex (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}

Create a mutex, initialized unlocked. \mbox{\Hypertarget{_s_d_l__mutex_8h_ab8c1a20a5466281a5d63a0cabe07e140}\label{_s_d_l__mutex_8h_ab8c1a20a5466281a5d63a0cabe07e140}} 
\index{SDL\_mutex.h@{SDL\_mutex.h}!SDL\_CreateSemaphore@{SDL\_CreateSemaphore}}
\index{SDL\_CreateSemaphore@{SDL\_CreateSemaphore}!SDL\_mutex.h@{SDL\_mutex.h}}
\doxysubsubsection{\texorpdfstring{SDL\_CreateSemaphore()}{SDL\_CreateSemaphore()}}
{\footnotesize\ttfamily DECLSPEC SDL\+\_\+sem$\ast$ SDLCALL SDL\+\_\+\+Create\+Semaphore (\begin{DoxyParamCaption}\item[{Uint32}]{initial\+\_\+value }\end{DoxyParamCaption})}

Create a semaphore, initialized with value, returns NULL on failure. \mbox{\Hypertarget{_s_d_l__mutex_8h_a8843feeb270845e07fc23f692707540f}\label{_s_d_l__mutex_8h_a8843feeb270845e07fc23f692707540f}} 
\index{SDL\_mutex.h@{SDL\_mutex.h}!SDL\_DestroyCond@{SDL\_DestroyCond}}
\index{SDL\_DestroyCond@{SDL\_DestroyCond}!SDL\_mutex.h@{SDL\_mutex.h}}
\doxysubsubsection{\texorpdfstring{SDL\_DestroyCond()}{SDL\_DestroyCond()}}
{\footnotesize\ttfamily DECLSPEC void SDLCALL SDL\+\_\+\+Destroy\+Cond (\begin{DoxyParamCaption}\item[{SDL\+\_\+cond $\ast$}]{cond }\end{DoxyParamCaption})}

Destroy a condition variable. \mbox{\Hypertarget{_s_d_l__mutex_8h_ad2bbcc4e32ac927af62f0cba671f63fe}\label{_s_d_l__mutex_8h_ad2bbcc4e32ac927af62f0cba671f63fe}} 
\index{SDL\_mutex.h@{SDL\_mutex.h}!SDL\_DestroyMutex@{SDL\_DestroyMutex}}
\index{SDL\_DestroyMutex@{SDL\_DestroyMutex}!SDL\_mutex.h@{SDL\_mutex.h}}
\doxysubsubsection{\texorpdfstring{SDL\_DestroyMutex()}{SDL\_DestroyMutex()}}
{\footnotesize\ttfamily DECLSPEC void SDLCALL SDL\+\_\+\+Destroy\+Mutex (\begin{DoxyParamCaption}\item[{SDL\+\_\+mutex $\ast$}]{mutex }\end{DoxyParamCaption})}

Destroy a mutex. \mbox{\Hypertarget{_s_d_l__mutex_8h_a23deb3b7e29a5137d804e4be3453a768}\label{_s_d_l__mutex_8h_a23deb3b7e29a5137d804e4be3453a768}} 
\index{SDL\_mutex.h@{SDL\_mutex.h}!SDL\_DestroySemaphore@{SDL\_DestroySemaphore}}
\index{SDL\_DestroySemaphore@{SDL\_DestroySemaphore}!SDL\_mutex.h@{SDL\_mutex.h}}
\doxysubsubsection{\texorpdfstring{SDL\_DestroySemaphore()}{SDL\_DestroySemaphore()}}
{\footnotesize\ttfamily DECLSPEC void SDLCALL SDL\+\_\+\+Destroy\+Semaphore (\begin{DoxyParamCaption}\item[{SDL\+\_\+sem $\ast$}]{sem }\end{DoxyParamCaption})}

Destroy a semaphore. \mbox{\Hypertarget{_s_d_l__mutex_8h_a0c50f774babf7a44c381238a1f780595}\label{_s_d_l__mutex_8h_a0c50f774babf7a44c381238a1f780595}} 
\index{SDL\_mutex.h@{SDL\_mutex.h}!SDL\_SemPost@{SDL\_SemPost}}
\index{SDL\_SemPost@{SDL\_SemPost}!SDL\_mutex.h@{SDL\_mutex.h}}
\doxysubsubsection{\texorpdfstring{SDL\_SemPost()}{SDL\_SemPost()}}
{\footnotesize\ttfamily DECLSPEC int SDLCALL SDL\+\_\+\+Sem\+Post (\begin{DoxyParamCaption}\item[{SDL\+\_\+sem $\ast$}]{sem }\end{DoxyParamCaption})}

Atomically increases the semaphore\textquotesingle{}s count (not blocking).

\begin{DoxyReturn}{Renvoie}
0, or -\/1 on error. 
\end{DoxyReturn}
\mbox{\Hypertarget{_s_d_l__mutex_8h_a517288aaa856ce2264e8420636e85c4a}\label{_s_d_l__mutex_8h_a517288aaa856ce2264e8420636e85c4a}} 
\index{SDL\_mutex.h@{SDL\_mutex.h}!SDL\_SemTryWait@{SDL\_SemTryWait}}
\index{SDL\_SemTryWait@{SDL\_SemTryWait}!SDL\_mutex.h@{SDL\_mutex.h}}
\doxysubsubsection{\texorpdfstring{SDL\_SemTryWait()}{SDL\_SemTryWait()}}
{\footnotesize\ttfamily DECLSPEC int SDLCALL SDL\+\_\+\+Sem\+Try\+Wait (\begin{DoxyParamCaption}\item[{SDL\+\_\+sem $\ast$}]{sem }\end{DoxyParamCaption})}

Non-\/blocking variant of \mbox{\hyperlink{_s_d_l__mutex_8h_af51d75d18cb90f28b35c31e853b04792}{SDL\+\_\+\+Sem\+Wait()}}.

\begin{DoxyReturn}{Renvoie}
0 if the wait succeeds, \mbox{\hyperlink{_s_d_l__mutex_8h_a1214610634c24465d7c50149752791a9}{SDL\+\_\+\+MUTEX\+\_\+\+TIMEDOUT}} if the wait would block, and -\/1 on error. 
\end{DoxyReturn}
\mbox{\Hypertarget{_s_d_l__mutex_8h_ae66390dca585fdab8de871fe32935768}\label{_s_d_l__mutex_8h_ae66390dca585fdab8de871fe32935768}} 
\index{SDL\_mutex.h@{SDL\_mutex.h}!SDL\_SemValue@{SDL\_SemValue}}
\index{SDL\_SemValue@{SDL\_SemValue}!SDL\_mutex.h@{SDL\_mutex.h}}
\doxysubsubsection{\texorpdfstring{SDL\_SemValue()}{SDL\_SemValue()}}
{\footnotesize\ttfamily DECLSPEC Uint32 SDLCALL SDL\+\_\+\+Sem\+Value (\begin{DoxyParamCaption}\item[{SDL\+\_\+sem $\ast$}]{sem }\end{DoxyParamCaption})}

Returns the current count of the semaphore. \mbox{\Hypertarget{_s_d_l__mutex_8h_af51d75d18cb90f28b35c31e853b04792}\label{_s_d_l__mutex_8h_af51d75d18cb90f28b35c31e853b04792}} 
\index{SDL\_mutex.h@{SDL\_mutex.h}!SDL\_SemWait@{SDL\_SemWait}}
\index{SDL\_SemWait@{SDL\_SemWait}!SDL\_mutex.h@{SDL\_mutex.h}}
\doxysubsubsection{\texorpdfstring{SDL\_SemWait()}{SDL\_SemWait()}}
{\footnotesize\ttfamily DECLSPEC int SDLCALL SDL\+\_\+\+Sem\+Wait (\begin{DoxyParamCaption}\item[{SDL\+\_\+sem $\ast$}]{sem }\end{DoxyParamCaption})}

This function suspends the calling thread until the semaphore pointed to by {\ttfamily sem} has a positive count. It then atomically decreases the semaphore count. \mbox{\Hypertarget{_s_d_l__mutex_8h_a4ea1acfaf722895626174e1e37c497da}\label{_s_d_l__mutex_8h_a4ea1acfaf722895626174e1e37c497da}} 
\index{SDL\_mutex.h@{SDL\_mutex.h}!SDL\_SemWaitTimeout@{SDL\_SemWaitTimeout}}
\index{SDL\_SemWaitTimeout@{SDL\_SemWaitTimeout}!SDL\_mutex.h@{SDL\_mutex.h}}
\doxysubsubsection{\texorpdfstring{SDL\_SemWaitTimeout()}{SDL\_SemWaitTimeout()}}
{\footnotesize\ttfamily DECLSPEC int SDLCALL SDL\+\_\+\+Sem\+Wait\+Timeout (\begin{DoxyParamCaption}\item[{SDL\+\_\+sem $\ast$}]{sem,  }\item[{Uint32}]{ms }\end{DoxyParamCaption})}

Variant of \mbox{\hyperlink{_s_d_l__mutex_8h_af51d75d18cb90f28b35c31e853b04792}{SDL\+\_\+\+Sem\+Wait()}} with a timeout in milliseconds.

\begin{DoxyReturn}{Renvoie}
0 if the wait succeeds, \mbox{\hyperlink{_s_d_l__mutex_8h_a1214610634c24465d7c50149752791a9}{SDL\+\_\+\+MUTEX\+\_\+\+TIMEDOUT}} if the wait does not succeed in the allotted time, and -\/1 on error.
\end{DoxyReturn}
\begin{DoxyWarning}{Avertissement}
On some platforms this function is implemented by looping with a delay of 1 ms, and so should be avoided if possible. 
\end{DoxyWarning}
\mbox{\Hypertarget{_s_d_l__mutex_8h_a5097fb4c7147d14a4c6df4515ec862e8}\label{_s_d_l__mutex_8h_a5097fb4c7147d14a4c6df4515ec862e8}} 
\index{SDL\_mutex.h@{SDL\_mutex.h}!SDL\_TryLockMutex@{SDL\_TryLockMutex}}
\index{SDL\_TryLockMutex@{SDL\_TryLockMutex}!SDL\_mutex.h@{SDL\_mutex.h}}
\doxysubsubsection{\texorpdfstring{SDL\_TryLockMutex()}{SDL\_TryLockMutex()}}
{\footnotesize\ttfamily DECLSPEC int SDLCALL SDL\+\_\+\+Try\+Lock\+Mutex (\begin{DoxyParamCaption}\item[{SDL\+\_\+mutex $\ast$}]{mutex }\end{DoxyParamCaption})}

Try to lock the mutex

\begin{DoxyReturn}{Renvoie}
0, SDL\+\_\+\+MUTEX\+\_\+\+TIMEDOUT, or -\/1 on error 
\end{DoxyReturn}
